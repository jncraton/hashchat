<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>hashchat</title>
    <link rel="stylesheet" href="https://jncraton.github.io/docss/do.min.css" />
    <style>
      :root {
        --w: 960px;
      }

      textarea {
        resize: none;
      }

      /* minigfm inserts <br> elements and fails to wrap <li>, so we clean that up */
      br {
        display: none;
      }

      li {
        margin-left: 2em;
      }
    </style>
    <script src="minigfm.js"></script>
    <link rel="icon" href="favicon.ico" />
  </head>
  <body>
    <main>
      <label>Prompt<textarea id="userPrompt" rows="5" placeholder="Enter your prompt" autofocus></textarea></label>
      <article id="responseMarkdownElement"></article>
      <details>
        <summary>Generation Config</summary>
        <label>
          Model
          <select id="model" autocomplete="off">
            <option value="gemini-pro-latest">Gemini Pro Latest</option>
            <option value="gemini-flash-latest" selected>Gemini Flash Latest</option>
            <option value="gemini-flash-lite-latest">Gemini Flash Lite Latest</option>
          </select>
        </label>
        <label>
          Temperature
          <input id="temperature" type="number" min="0" max="2" step=".1" value="0" />
        </label>
        <label>
          Thinking Tokens
          <input id="thinking" type="number" min="0" max="32768" step="1024" value="0" />
        </label>
        <label>
          System
          <textarea id="system" rows="5" autocomplete="off">
  Respond avoiding overly complex sentence structure.

  Never use emojis. Use only basic ascii characters.

  Never use **bold** or *italics*, even for headings and list items. Can use other markdown formatting including blockquotes and fenced code blocks as appropriate.

  Never use smart quotes or em dashes.
          </textarea>
        </label>
      </details>
      <details>
        <summary>Response Source</summary>
        <pre id="responseElement"></pre>
      </details>
      <button id="copy">Copy Response Source ðŸ“‹</button>
    </main>

    <script>
      async function encode(text) {
        let stream = new Blob([text]).stream()

        stream = stream.pipeThrough(new CompressionStream('deflate-raw'))
        const res = await new Response(stream)

        const blob = await res.blob()
        const buffer = await blob.arrayBuffer()

        return ';' + btoa(String.fromCharCode(...new Uint8Array(buffer)))
      }

      async function decode(text) {
        if (text[0] != ';') {
          console.error('Invalid encoding for text', text)
          return
        }
        text = text.slice(1)

        const binary = Uint8Array.from(atob(text), c => c.charCodeAt(0))

        let stream = new Blob([binary]).stream()

        stream = stream.pipeThrough(new DecompressionStream('deflate-raw'))

        const res = await new Response(stream)
        const blob = await res.blob()

        return await blob.text()
      }

      const chat = async () => {
        localStorage.geminiKey = localStorage.geminiKey || prompt('Gemini Key')

        if (!userPrompt.value) {
          alert('Please enter a prompt.')
          return
        }

        responseElement.textContent = ''

        const url = `https://generativelanguage.googleapis.com/v1beta/models/${model.value}:streamGenerateContent?alt=sse`

        try {
          const response = await fetch(url, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'x-goog-api-key': localStorage.geminiKey,
            },
            body: JSON.stringify({
              contents: [
                {
                  parts: [
                    {
                      text: system.value.trim() + '\n\n' + userPrompt.value,
                    },
                  ],
                },
              ],
              tools: [
                {
                  url_context: {},
                },
              ],
              generationConfig: {
                thinkingConfig: {
                  thinkingBudget: thinking.value,
                },
                temperature: temperature.value,
              },
            }),
          })

          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`)
          }

          const reader = response.body.getReader()
          const decoder = new TextDecoder()

          while (true) {
            const { done, value } = await reader.read()
            if (done) {
              break
            }
            const chunk = decoder.decode(value)
            const lines = chunk.split('\n')
            for (const line of lines) {
              if (line.startsWith('data:')) {
                const jsonString = line.substring(5).trim()
                if (jsonString) {
                  try {
                    const json = JSON.parse(jsonString)
                    console.log(json)
                    if (json.candidates && json.candidates[0].content && json.candidates[0].content.parts[0]) {
                      const part = json.candidates[0].content.parts[0]
                      if (part.text) responseElement.textContent += part.text
                      if (part.executableCode)
                        responseElement.textContent += '\n\n## Executable Code\n\n' + part.executableCode.code
                      if (part.codeExecutionResult)
                        responseElement.textContent +=
                          '\n\n## Execution Result\n\n' + part.codeExecutionResult.output + '\n-----\n\n'
                      responseElement.textContent = responseElement.textContent.replaceAll(
                        /^    ([\*\-])   /gm,
                        '    $1 ',
                      )
                      responseElement.textContent = responseElement.textContent.replaceAll(/(^\d+\. )[ ]+/gm, '$1')
                      updateResponse(responseElement.textContent)
                      updateHash()
                    }
                  } catch (e) {
                    console.error('Error parsing JSON:', e)
                  }
                }
              }
            }
          }
        } catch (error) {
          console.error('Error:', error)
          responseElement.textContent = `Error: ${error.message}`
        }
      }

      const copyResponse = async () => {
        await navigator.clipboard.writeText(responseElement.textContent)
      }

      copy.addEventListener('click', copyResponse)

      document.addEventListener('keydown', function (ev) {
        if ((ev.key === 'c' || ev.key === 'C') && (ev.ctrlKey || ev.metaKey)) {
          copyResponse()
        }
      })

      document.querySelector('textarea').addEventListener('keydown', async e => {
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault()
          chat()
        } else {
          return
        }
      })

      async function init() {
        if (location.hash.slice(1)) {
          let prompt
          let response

          if (location.hash[1] == ';') {
            let hash = await decode(location.hash.slice(1))
            ;[prompt, response] = JSON.parse(hash)
          } else {
            ;[prompt, response] = location.hash.slice(1).split(';')

            prompt = decodeURIComponent(prompt)
            response = response ? decodeURIComponent(response) : null
          }

          userPrompt.value = prompt

          if (response) {
            updateResponse(response)
          } else {
            chat()
          }
        }
      }
      window.addEventListener('load', init)

      const updateHash = async () => {
        location.hash = await encode(JSON.stringify([userPrompt.value, responseElement.textContent]))
      }

      const updateResponse = response => {
        const md = new MiniGFM()
        responseElement.textContent = response
        responseMarkdownElement.innerHTML = md.parse(response)
      }
    </script>
  </body>
</html>
