<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>hashchat</title>
    <link rel="stylesheet" href="do.min.css" />
    <style>
      :root {
        --w: 960px;
      }

      textarea {
        resize: none;
      }

      #responseInfo {
        display: none;
      }

      /* minigfm inserts <br> elements and fails to wrap <li>, so we clean that up */
      br {
        display: none;
      }

      li {
        margin-left: 2em;
      }
    </style>
    <script src="minigfm.js"></script>
    <link rel="icon" href="favicon.ico" />
  </head>
  <body>
    <main>
      <article id="responseMarkdownElement"></article>
      <label>Prompt<textarea id="userPrompt" rows="5" placeholder="Enter your prompt"></textarea></label>
      <details>
        <summary>Generation Config</summary>
        <label>
          Model
          <select id="model" autocomplete="off">
            <option value="gemini-pro-latest">Gemini Pro Latest</option>
            <option value="gemini-flash-latest" selected>Gemini Flash Latest</option>
            <option value="gemini-flash-lite-latest">Gemini Flash Lite Latest</option>
          </select>
        </label>
        <label>
          Temperature
          <input id="temperature" type="number" min="0" max="2" step=".1" value="0" />
        </label>
        <label>
          Thinking Tokens
          <input id="thinking" type="number" min="0" max="32768" step="1024" value="0" />
        </label>
        <label>
          System
          <textarea id="system" rows="5" autocomplete="off">
Respond avoiding overly complex sentence structure.

Never use emojis. Use only basic ascii characters.

Never use **bold** or *italics*, even for headings and list items. Can use other markdown formatting including blockquotes and fenced code blocks as appropriate.

Never use smart quotes or em dashes.

{% if revealjs %}
## Formatting

The slides should be in markdown format that will be used to generate a reveal.js presentation using pandoc.

Slides will be split on 2nd level headings (##). Horizontal rules should only be used to separate slides without headings.

The first slide should use a level 1 heading and include no content other than the title. Other slides should use level 2 headings. The title should reflect the content of the presentation and never use the word "lecture" or "presnetation".

Slide titles should never be more than 3 words.

Favor many small slides over a few large slides. Never include more than 20 words on a slide.

If a list is used on a slide, do not end list item text with a period.

Properly fence any code examples on slides.

The deck should include 20 to 30 slides.

The entire response must only the slide deck. Do not include any introductory or concluding text.

## Example

```
# Title

## Slide 1 Title

- Some info
- More info

---

What do you think of that?

## Slide 2 Title

- Some info
- More info

## Exercise

Application exercise

## Slide 3 Title

- Some info
- More info

## Exercise

Synthesis exercise
```
{% endif %}

{% if lecture %}
## Persona

You are a Professor of Practice who specializes in high quality, engaging undergraduate education.

## Pedagogy

Include three or four discussion questions. There should be only one question per slide, and those slides should not have titles or headings.

Include two or three exercises that could be worked by students in the classroom in a few minutes. Always end with a small exercise. Each exercise should simply have the heading "## Exercise".

Do not wrap up with a generic "Questions?" or review slide.

Include exercises and discussion questions throughout the presentation. Do not put them all together.
{% endif %}


          </textarea>
        </label>
      </details>
      <section id="responseInfo">
        <details>
          <summary>Response Source</summary>
          <pre id="responseElement"></pre>
        </details>
        <button id="copy">Copy Response Source ðŸ“‹</button>
      </section>
    </main>

    <script>
      async function encode(text) {
        let stream = new Blob([text]).stream()

        stream = stream.pipeThrough(new CompressionStream('deflate-raw'))
        const res = await new Response(stream)

        const blob = await res.blob()
        const buffer = await blob.arrayBuffer()

        return ';' + btoa(String.fromCharCode(...new Uint8Array(buffer)))
      }

      async function decode(text) {
        if (text[0] != ';') {
          console.error('Invalid encoding for text', text)
          return
        }
        text = text.slice(1)

        const binary = Uint8Array.from(atob(text), c => c.charCodeAt(0))

        let stream = new Blob([binary]).stream()

        stream = stream.pipeThrough(new DecompressionStream('deflate-raw'))

        const res = await new Response(stream)
        const blob = await res.blob()

        return await blob.text()
      }

      const chat = async () => {
        localStorage.geminiKey = localStorage.geminiKey || prompt('Gemini Key')

        if (!userPrompt.value) {
          alert('Please enter a prompt.')
          return
        }

        responseElement.textContent = ''

        let sysPrompt = system.value.trim()
        sysPrompt = sysPrompt.replace(/{% if (.*?) %}(.*?){% endif %}/gms, (_, kw, src) => {
          if (userPrompt.value.toLowerCase().includes(kw)) {
            console.log(`Including ${kw} in prompt`)
            return src
          } else {
            return ''
          }
        })

        const url = `https://generativelanguage.googleapis.com/v1beta/models/${model.value}:streamGenerateContent?alt=sse`

        console.log(sysPrompt)

        try {
          const response = await fetch(url, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'x-goog-api-key': localStorage.geminiKey,
            },
            body: JSON.stringify({
              system_instruction: {
                parts: [
                  {
                    text: sysPrompt,
                  },
                ],
              },
              contents: [
                {
                  parts: [
                    {
                      text: userPrompt.value,
                    },
                  ],
                },
              ],
              tools: [
                {
                  url_context: {},
                },
              ],
              generationConfig: {
                thinkingConfig: {
                  thinkingBudget: thinking.value,
                },
                temperature: temperature.value,
              },
            }),
          })

          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`)
          }

          const reader = response.body.getReader()
          const decoder = new TextDecoder()

          while (true) {
            const { done, value } = await reader.read()
            if (done) {
              break
            }
            const chunk = decoder.decode(value)
            const lines = chunk.split('\n')
            for (const line of lines) {
              if (line.startsWith('data:')) {
                const jsonString = line.substring(5).trim()
                if (jsonString) {
                  try {
                    const json = JSON.parse(jsonString)
                    console.log(json)
                    if (json.candidates && json.candidates[0].content && json.candidates[0].content.parts[0]) {
                      const part = json.candidates[0].content.parts[0]
                      if (part.text) responseElement.textContent += part.text
                      if (part.executableCode)
                        responseElement.textContent += '\n\n## Executable Code\n\n' + part.executableCode.code
                      if (part.codeExecutionResult)
                        responseElement.textContent +=
                          '\n\n## Execution Result\n\n' + part.codeExecutionResult.output + '\n-----\n\n'

                      updateResponse(responseElement.textContent)
                      updateHash()
                    }
                  } catch (e) {
                    console.error('Error parsing JSON:', e)
                  }
                }
              }
            }
          }
        } catch (error) {
          console.error('Error:', error)
          responseElement.textContent = `Error: ${error.message}`
        }
      }

      const copyResponse = async () => {
        await navigator.clipboard.writeText(responseElement.textContent)
      }

      copy.addEventListener('click', copyResponse)

      document.addEventListener('keydown', function (ev) {
        if ((ev.key === 'c' || ev.key === 'C') && (ev.ctrlKey || ev.metaKey)) {
          copyResponse()
        }
      })

      document.querySelector('textarea').addEventListener('keydown', async e => {
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault()
          chat()
        } else {
          return
        }
      })

      async function init() {
        if (location.hash.slice(1)) {
          let prompt
          let response

          if (location.hash[1] == ';') {
            let hash = await decode(location.hash.slice(1))
            ;[prompt, response] = JSON.parse(hash)
          } else {
            ;[prompt, response] = location.hash.slice(1).split(';')

            prompt = decodeURIComponent(prompt)
            response = response ? decodeURIComponent(response) : null
          }

          userPrompt.value = prompt

          if (response) {
            updateResponse(response)
          } else {
            chat()
          }
        } else {
          userPrompt.focus()
        }
      }
      window.addEventListener('load', init)

      const updateHash = async () => {
        location.hash = await encode(JSON.stringify([userPrompt.value, responseElement.textContent]))
      }

      const updateResponse = response => {
        if (response) {
          const md = new MiniGFM()
          responseElement.textContent = response
          responseMarkdownElement.innerHTML = md.parse(response)

          responseInfo.style.display = 'block'
        }
      }
    </script>
  </body>
</html>
