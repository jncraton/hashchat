<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>hashchat</title>
    <style>
      :root {
        width: 600px;
        margin: 0 auto;
        font-family: sans serif;
        font-size: 16px;
      }

      button {
        float: right;
      }

      textarea {
        width: 100%;
        resize: none;
        font-size: 1rem;
      }

      pre {
        text-wrap: wrap;
      }
    </style>
    <link rel="icon" href="favicon.ico" />
  </head>
  <body>
    <textarea id="userPrompt" rows="5" placeholder="Enter your prompt"></textarea>
    <details>
      <summary>Config</summary>
      <label>
        Model
        <select id="model" autocomplete="off">
          <option value="gemini-pro-latest">Gemini Pro Latest</option>
          <option value="gemini-flash-latest" selected>Gemini Flash Latest</option>
          <option value="gemini-flash-lite-latest">Gemini Flash Lite Latest</option>
        </select>
      </label>
      <label>
        Temperature
        <input id="temperature" type="number" min="0" max="2" step=".1" value="0" />
      </label>
      <label>
        Thinking Tokens
        <input id="thinking" type="number" min="0" max="32768" step="1024" value="0" />
      </label>
      <label>
        System
        <textarea id="system" rows="5" autocomplete="off">
Respond avoiding overly complex sentence structure.

Never use emojis. Use only basic ascii characters.

Never use **bold** or *italics*, even for headings and list items. Can use other markdown formatting including blockquotes and fenced code blocks as appropriate.

Never use smart quotes or em dashes.
        </textarea>
      </label>
    </details>
    <h2>
      Response
      <button id="copy">Copy ðŸ“‹</button>
    </h2>
    <pre id="responseElement"></pre>

    <script>
      const chat = async () => {
        localStorage.geminiKey = localStorage.geminiKey || prompt('Gemini Key')

        if (!userPrompt.value) {
          alert('Please enter a prompt.')
          return
        }

        responseElement.textContent = ''

        const url = `https://generativelanguage.googleapis.com/v1beta/models/${model.value}:streamGenerateContent?alt=sse`

        try {
          const response = await fetch(url, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'x-goog-api-key': localStorage.geminiKey,
            },
            body: JSON.stringify({
              contents: [
                {
                  parts: [
                    {
                      text: system.value.trim() + '\n\n' + userPrompt.value,
                    },
                  ],
                },
              ],
              tools: [
                {
                  url_context: {},
                },
              ],
              generationConfig: {
                thinkingConfig: {
                  thinkingBudget: thinking.value,
                },
                temperature: temperature.value,
              },
            }),
          })

          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`)
          }

          const reader = response.body.getReader()
          const decoder = new TextDecoder()

          while (true) {
            const { done, value } = await reader.read()
            if (done) {
              break
            }
            const chunk = decoder.decode(value)
            const lines = chunk.split('\n')
            for (const line of lines) {
              if (line.startsWith('data:')) {
                const jsonString = line.substring(5).trim()
                if (jsonString) {
                  try {
                    const json = JSON.parse(jsonString)
                    console.log(json)
                    if (json.candidates && json.candidates[0].content && json.candidates[0].content.parts[0]) {
                      const part = json.candidates[0].content.parts[0]
                      if (part.text) responseElement.textContent += part.text
                      if (part.executableCode)
                        responseElement.textContent += '\n\n## Executable Code\n\n' + part.executableCode.code
                      if (part.codeExecutionResult)
                        responseElement.textContent +=
                          '\n\n## Execution Result\n\n' + part.codeExecutionResult.output + '\n-----\n\n'
                      responseElement.textContent = responseElement.textContent.replaceAll(/^    ([\*\-])   /gm, '    $1 ')
                      responseElement.textContent = responseElement.textContent.replaceAll(/(^\d+\. )[ ]+/gm, '$1')
                      updateHash()
                    }
                  } catch (e) {
                    console.error('Error parsing JSON:', e)
                  }
                }
              }
            }
          }
        } catch (error) {
          console.error('Error:', error)
          responseElement.textContent = `Error: ${error.message}`
        }
      }

      const copyResponse = async () => {
        await navigator.clipboard.writeText(responseElement.textContent)
      }

      copy.addEventListener('click', copyResponse)

      document.addEventListener('keydown', function (ev) {
        if ((ev.key === 'c' || ev.key === 'C') && (ev.ctrlKey || ev.metaKey)) {
          copyResponse()
        }
      })

      document.querySelector('textarea').addEventListener('keydown', async e => {
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault()
          chat()
        } else {
          return
        }
      })

      if (location.hash.slice(1)) {
        const [prompt, response] = location.hash.slice(1).split(';')

        userPrompt.value = decodeURIComponent(prompt)

        if (response) {
          responseElement.textContent = decodeURIComponent(response)
        } else {
          chat()
        }
      }

      const updateHash = () => {
        location.hash = encodeURIComponent(userPrompt.value) + ';' + encodeURIComponent(responseElement.textContent)
      }
    </script>
  </body>
</html>
